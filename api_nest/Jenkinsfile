pipeline {
    agent {
        docker {
            image 'docker:24.0-cli'
            args '-v /var/run/docker.sock:/var/run/docker.sock --user root --network host'
        }
    }

    environment {
        DATABASE_URL = credentials('DATABASE_URL')
        MYSQL_ROOT_PASSWORD = credentials('MYSQL_ROOT_PASSWORD')
        MYSQL_DATABASE = credentials('MYSQL_DATABASE')
        MYSQL_USER = credentials('MYSQL_USER')

        REDIS_HOST = credentials('REDIS_HOST')
        REDIS_PORT = credentials('REDIS_PORT')

        JWT_SECRET = credentials('JWT_SECRET')

        DEFAULT_PAGE = credentials('DEFAULT_PAGE')
        MAX_PAGE_DEFAULT_LIMIT = credentials('MAX_PAGE_DEFAULT_LIMIT')

        // --- Docker Compose Files ---
        COMPOSE_FILES = '--project-directory . --env-file /dev/null -f api_nest/docker-compose.yml -f api_nest/docker-compose.prod.yml'
    }

    stages {
        stage('Build Service') {
            steps {
                script {
                    echo 'Building service...'
                    dir('api_nest') {
                        sh 'docker build -t games-e-commerce-api_main-app -f prod.Dockerfile .'
                    }
                }
            }
        }

        stage('Start Dependencies for Testing') {
            steps {
                script {
                    sh """
                        echo "DATABASE_URL=${env.DATABASE_URL}" > .env
                        echo "MYSQL_ROOT_PASSWORD=${env.MYSQL_ROOT_PASSWORD}" >> .env
                        echo "MYSQL_DATABASE=${env.MYSQL_DATABASE}" >> .env
                        echo "MYSQL_USER=${env.MYSQL_USER}" >> .env
                        echo "REDIS_HOST=${env.REDIS_HOST}" >> .env
                        echo "REDIS_PORT=${env.REDIS_PORT}" >> .env
                        echo "JWT_SECRET=${env.JWT_SECRET}" >> .env
                        echo "DEFAULT_PAGE=${env.DEFAULT_PAGE}" >> .env
                        echo "MAX_PAGE_DEFAULT_LIMIT=${env.MAX_PAGE_DEFAULT_LIMIT}" >> .env
                    """

                    def composeFiles = env.COMPOSE_FILES.replace('--env-file /dev/null', '--env-file .env')

                    echo 'Cleaning up any old containers before starting...'
                    sh "docker compose ${composeFiles} down --remove-orphans || true"

                    echo 'Starting database and dependency containers...'
                    sh "docker compose ${composeFiles} up -d --no-build"
                }
            }
        }

        stage('Run Unit and E2E Tests') {
            steps {
                script {
                    echo 'Waiting for services to be ready...'

                    // This script waits for the services to become available before running tests.
                    sh """
                        TIMEOUT=120
                        INTERVAL=5
                        
                        echo "Waiting for MySQL..."
                        # Parse the port from the URL
                        DB_PORT=\$(echo \$DATABASE_URL | awk -F'[@:/]' '{print \$7}')

                        ELAPSED=0
                        # Connect to localhost since the agent is on the host network
                        while ! nc -z localhost \$DB_PORT; do
                            if [ \$ELAPSED -ge \$TIMEOUT ]; then
                                echo "Timed out waiting for MySQL."
                                exit 1
                            fi
                            sleep \$INTERVAL
                            ELAPSED=\$((ELAPSED + INTERVAL))
                        done
                        echo "MySQL is up!"

                        # Reset timer for next service
                        ELAPSED=0
                        
                        echo "Waiting for Redis on localhost:\${REDIS_PORT}..."
                        while ! nc -z localhost \${REDIS_PORT}; do
                            if [ \$ELAPSED -ge \$TIMEOUT ]; then
                                echo "Timed out waiting for Redis."
                                exit 1
                            fi
                            sleep \$INTERVAL
                            ELAPSED=\$((ELAPSED + INTERVAL))
                        done
                        echo "Redis is up!"

                        echo "Waiting for app service..."
                        ELAPSED=0
                        while ! docker compose ${env.COMPOSE_FILES} ps app | grep -q "Up"; do
                            if [ \$ELAPSED -ge \$TIMEOUT ]; then
                                echo "Timed out waiting for app service."
                                echo "--- api_nest logs ---"
                                docker compose ${env.COMPOSE_FILES} logs app || echo "Could not retrieve logs for app."
                                exit 1
                            fi
                            sleep \$INTERVAL
                            ELAPSED=\$((ELAPSED + INTERVAL))
                        done
                        echo "app service is running!"
                    """

                    echo 'Running tests...'

                    // sh "docker compose ${env.OMPOSE_FILES} exec -T --user root app npm ci"
                    // sh "docker compose ${env.COMPOSE_FILES} exec -T app npm test"
                    // sh "docker compose ${env.COMPOSE_FILES} exec -T app npm test:e2e"
                }
            }
        }

        // when using a docker hub alike, you may want to add a stage for deployment
        // stage('Deploy to Production') {
        //     steps {
        //         script {
        //         }
        //     }
        // }
    }
}